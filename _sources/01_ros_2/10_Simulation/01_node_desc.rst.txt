Node description
================

The ``/joint_state_broadcaster`` node is part of the `ROS2 control package <https://control.ros.org/humble/index.html>`_.
More details can be found `here <https://control.ros.org/humble/doc/ros2_controllers/joint_state_broadcaster/doc/userdoc.html>`_,
but essentially the broadcaster reads all state interfaces and reports them on the ``/joint_states`` topic.

Such data is collected by the ``/robot_state_publisher`` node (package `Robot State
Publisher <https://github.com/ros/robot_state_publisher>`_) that combines the knowledge of
the robot's kinematics to publish the full tree of transformations for the different links
on the topics ``/tf`` and ``/tf_static``.

The ``/motion_control_handle`` node is still part of ROS2 control, but in this case it
spawns an handle that can be moved in RViz that specifies the target position of the robot;
the information is published on the ``/target_frame`` topic.

The target is collected by the ``/cartesian_mototion_controller`` node (generated by the
ROS2 control package but can load any custom controller that implements the
``CartesianMotionController`` interface) that computes the commands to be sent to the
robot.

The ``sim_ros2_interface`` node is instead provided by :ref:`CoppeliaSim<coppeliasim>` and
is the bridge between the ROS2 world (in which the control is computed) and the Coppelia
world (in which the system is simulated).

As mentioned `here <https://robotics.stackexchange.com/questions/104551/how-does-anything-listen-to-tf2-what-are-the-transform-listener-impl-nodes>`_,
the ``/transform_listener_impl_<>`` nodes are automatically spawned in order to ensure
a reliable transformation processing.

**Note**: missing the description of the ``/robot_controller`` node.

Finally, the standalone ``/controller_manager`` node, from ROS2 control, is the key topic
that needs to be enabled to manage the communication between the different control nodes.


